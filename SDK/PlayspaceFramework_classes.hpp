#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: PlayspaceFramework

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "PlayspaceFramework_structs.hpp"
#include "ModularGameplay_classes.hpp"


namespace SDK
{

// Class PlayspaceFramework.PlayspacePlayerController
// 0x0028 (0x0598 - 0x0570)
class APlayspacePlayerController : public APlayerController
{
public:
	uint8                                         Pad_3F5D[0x18];                                    // 0x0570(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bUsePlayerSpawningComponent;                       // 0x0588(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F5E[0x7];                                     // 0x0589(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UPlayspaceControllerComponent_PlayerSpawning> ControllerSpawningComponent;                       // 0x0590(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspacePlayerController">();
	}
	static class APlayspacePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayspacePlayerController>();
	}
};
static_assert(alignof(APlayspacePlayerController) == 0x000008, "Wrong alignment on APlayspacePlayerController");
static_assert(sizeof(APlayspacePlayerController) == 0x000598, "Wrong size on APlayspacePlayerController");
static_assert(offsetof(APlayspacePlayerController, bUsePlayerSpawningComponent) == 0x000588, "Member 'APlayspacePlayerController::bUsePlayerSpawningComponent' has a wrong offset!");
static_assert(offsetof(APlayspacePlayerController, ControllerSpawningComponent) == 0x000590, "Member 'APlayspacePlayerController::ControllerSpawningComponent' has a wrong offset!");

// Class PlayspaceFramework.PlayspaceGameState
// 0x0020 (0x02B0 - 0x0290)
class APlayspaceGameState : public AGameState
{
public:
	TSubclassOf<class APlayspace>                 RootPlayspaceClass;                                // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePlayspaceSystem;                               // 0x0298(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePlayerSpawningComponent;                       // 0x0299(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F5F[0x6];                                     // 0x029A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayspaceManagerComponent*             PlayspaceManagerComponentCached;                   // 0x02A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayspaceGameStateComponent_PlayerSpawningManager* PlayerSpawningManagerCached;                       // 0x02A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceGameState">();
	}
	static class APlayspaceGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayspaceGameState>();
	}
};
static_assert(alignof(APlayspaceGameState) == 0x000008, "Wrong alignment on APlayspaceGameState");
static_assert(sizeof(APlayspaceGameState) == 0x0002B0, "Wrong size on APlayspaceGameState");
static_assert(offsetof(APlayspaceGameState, RootPlayspaceClass) == 0x000290, "Member 'APlayspaceGameState::RootPlayspaceClass' has a wrong offset!");
static_assert(offsetof(APlayspaceGameState, bUsePlayspaceSystem) == 0x000298, "Member 'APlayspaceGameState::bUsePlayspaceSystem' has a wrong offset!");
static_assert(offsetof(APlayspaceGameState, bUsePlayerSpawningComponent) == 0x000299, "Member 'APlayspaceGameState::bUsePlayerSpawningComponent' has a wrong offset!");
static_assert(offsetof(APlayspaceGameState, PlayspaceManagerComponentCached) == 0x0002A0, "Member 'APlayspaceGameState::PlayspaceManagerComponentCached' has a wrong offset!");
static_assert(offsetof(APlayspaceGameState, PlayerSpawningManagerCached) == 0x0002A8, "Member 'APlayspaceGameState::PlayerSpawningManagerCached' has a wrong offset!");

// Class PlayspaceFramework.GameplayVolume
// 0x0080 (0x02A0 - 0x0220)
class AGameplayVolume : public AActor
{
public:
	TSoftClassPtr<class UClass>                   PlayspaceClassTemplate;                            // 0x0220(0x0028)(Edit, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APlayspace>                 PlayspaceClass;                                    // 0x0248(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APlayspace*                             Playspace;                                         // 0x0250(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  VolumeTags;                                        // 0x0258(0x0020)(Edit, Protected, NativeAccessSpecifierProtected)
	class UOverlapComponent*                      BoundsComponent;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F60[0x20];                                    // 0x0280(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateSize(const struct FVector& NewScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayVolume">();
	}
	static class AGameplayVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameplayVolume>();
	}
};
static_assert(alignof(AGameplayVolume) == 0x000008, "Wrong alignment on AGameplayVolume");
static_assert(sizeof(AGameplayVolume) == 0x0002A0, "Wrong size on AGameplayVolume");
static_assert(offsetof(AGameplayVolume, PlayspaceClassTemplate) == 0x000220, "Member 'AGameplayVolume::PlayspaceClassTemplate' has a wrong offset!");
static_assert(offsetof(AGameplayVolume, PlayspaceClass) == 0x000248, "Member 'AGameplayVolume::PlayspaceClass' has a wrong offset!");
static_assert(offsetof(AGameplayVolume, Playspace) == 0x000250, "Member 'AGameplayVolume::Playspace' has a wrong offset!");
static_assert(offsetof(AGameplayVolume, VolumeTags) == 0x000258, "Member 'AGameplayVolume::VolumeTags' has a wrong offset!");
static_assert(offsetof(AGameplayVolume, BoundsComponent) == 0x000278, "Member 'AGameplayVolume::BoundsComponent' has a wrong offset!");

// Class PlayspaceFramework.OverlapComponent
// 0x0020 (0x04E0 - 0x04C0)
class UOverlapComponent : public UStaticMeshComponent
{
public:
	uint8                                         Pad_3F61[0x20];                                    // 0x04C0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginActorOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndActorOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OverlapComponent">();
	}
	static class UOverlapComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOverlapComponent>();
	}
};
static_assert(alignof(UOverlapComponent) == 0x000010, "Wrong alignment on UOverlapComponent");
static_assert(sizeof(UOverlapComponent) == 0x0004E0, "Wrong size on UOverlapComponent");

// Class PlayspaceFramework.Playspace
// 0x01D0 (0x03F0 - 0x0220)
class APlayspace : public AInfo
{
public:
	uint8                                         Pad_3F65[0x30];                                    // 0x0220(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  GameplayTags;                                      // 0x0250(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           RequestedPlayspaceParentTag;                       // 0x0270(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class APlayspaceLogic>            PlayspaceLogicClass;                               // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TSubclassOf<class APlayspace>>         ChildPlayspaceClasses;                             // 0x0280(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FPlayspaceUserList                     PlayspaceUsers;                                    // 0x0290(0x0128)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	class APlayspaceLogic*                        PlayspaceLogic;                                    // 0x03B8(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class APlayspace*>                     ChildPlayspaces;                                   // 0x03C0(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FUniqueNetIdRepl>               PendingUsers;                                      // 0x03D0(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPlayspaceManagerComponent*             PlayspaceManagerCached;                            // 0x03E0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F66[0x8];                                     // 0x03E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_PlayspaceLogic();
	void OnRep_PlayspaceUsers();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Playspace">();
	}
	static class APlayspace* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayspace>();
	}
};
static_assert(alignof(APlayspace) == 0x000008, "Wrong alignment on APlayspace");
static_assert(sizeof(APlayspace) == 0x0003F0, "Wrong size on APlayspace");
static_assert(offsetof(APlayspace, GameplayTags) == 0x000250, "Member 'APlayspace::GameplayTags' has a wrong offset!");
static_assert(offsetof(APlayspace, RequestedPlayspaceParentTag) == 0x000270, "Member 'APlayspace::RequestedPlayspaceParentTag' has a wrong offset!");
static_assert(offsetof(APlayspace, PlayspaceLogicClass) == 0x000278, "Member 'APlayspace::PlayspaceLogicClass' has a wrong offset!");
static_assert(offsetof(APlayspace, ChildPlayspaceClasses) == 0x000280, "Member 'APlayspace::ChildPlayspaceClasses' has a wrong offset!");
static_assert(offsetof(APlayspace, PlayspaceUsers) == 0x000290, "Member 'APlayspace::PlayspaceUsers' has a wrong offset!");
static_assert(offsetof(APlayspace, PlayspaceLogic) == 0x0003B8, "Member 'APlayspace::PlayspaceLogic' has a wrong offset!");
static_assert(offsetof(APlayspace, ChildPlayspaces) == 0x0003C0, "Member 'APlayspace::ChildPlayspaces' has a wrong offset!");
static_assert(offsetof(APlayspace, PendingUsers) == 0x0003D0, "Member 'APlayspace::PendingUsers' has a wrong offset!");
static_assert(offsetof(APlayspace, PlayspaceManagerCached) == 0x0003E0, "Member 'APlayspace::PlayspaceManagerCached' has a wrong offset!");

// Class PlayspaceFramework.PlayspaceComponent
// 0x0000 (0x00B0 - 0x00B0)
class UPlayspaceComponent final : public UGameFrameworkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceComponent">();
	}
	static class UPlayspaceComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceComponent>();
	}
};
static_assert(alignof(UPlayspaceComponent) == 0x000008, "Wrong alignment on UPlayspaceComponent");
static_assert(sizeof(UPlayspaceComponent) == 0x0000B0, "Wrong size on UPlayspaceComponent");

// Class PlayspaceFramework.PlayspaceControllerComponent_PlayerSpawning
// 0x0038 (0x00E8 - 0x00B0)
class UPlayspaceControllerComponent_PlayerSpawning final : public UControllerComponent
{
public:
	FMulticastInlineDelegateProperty_             OnPlayerQueuedToSpawn;                             // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class ACameraActor*                           SpawnCameraActor;                                  // 0x00C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bClientReadyForSpawning;                           // 0x00C8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F67[0x3];                                     // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FReplicatedSpawnInfo                   ReplicatedSpawnInfo;                               // 0x00CC(0x001C)(Net, Transient, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)

public:
	void OnRep_ReplicatedSpawnInfo();
	void ServerMarkReadyForSpawning();

	const struct FReplicatedSpawnInfo GetSpawnInfo() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceControllerComponent_PlayerSpawning">();
	}
	static class UPlayspaceControllerComponent_PlayerSpawning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceControllerComponent_PlayerSpawning>();
	}
};
static_assert(alignof(UPlayspaceControllerComponent_PlayerSpawning) == 0x000008, "Wrong alignment on UPlayspaceControllerComponent_PlayerSpawning");
static_assert(sizeof(UPlayspaceControllerComponent_PlayerSpawning) == 0x0000E8, "Wrong size on UPlayspaceControllerComponent_PlayerSpawning");
static_assert(offsetof(UPlayspaceControllerComponent_PlayerSpawning, OnPlayerQueuedToSpawn) == 0x0000B0, "Member 'UPlayspaceControllerComponent_PlayerSpawning::OnPlayerQueuedToSpawn' has a wrong offset!");
static_assert(offsetof(UPlayspaceControllerComponent_PlayerSpawning, SpawnCameraActor) == 0x0000C0, "Member 'UPlayspaceControllerComponent_PlayerSpawning::SpawnCameraActor' has a wrong offset!");
static_assert(offsetof(UPlayspaceControllerComponent_PlayerSpawning, bClientReadyForSpawning) == 0x0000C8, "Member 'UPlayspaceControllerComponent_PlayerSpawning::bClientReadyForSpawning' has a wrong offset!");
static_assert(offsetof(UPlayspaceControllerComponent_PlayerSpawning, ReplicatedSpawnInfo) == 0x0000CC, "Member 'UPlayspaceControllerComponent_PlayerSpawning::ReplicatedSpawnInfo' has a wrong offset!");

// Class PlayspaceFramework.PlayspaceGameMode
// 0x0018 (0x0320 - 0x0308)
class APlayspaceGameMode : public AGameMode
{
public:
	uint8                                         Pad_3F68[0x18];                                    // 0x0308(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceGameMode">();
	}
	static class APlayspaceGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayspaceGameMode>();
	}
};
static_assert(alignof(APlayspaceGameMode) == 0x000008, "Wrong alignment on APlayspaceGameMode");
static_assert(sizeof(APlayspaceGameMode) == 0x000320, "Wrong size on APlayspaceGameMode");

// Class PlayspaceFramework.PlayspaceGameStateComponent
// 0x0000 (0x00B0 - 0x00B0)
class UPlayspaceGameStateComponent : public UGameStateComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceGameStateComponent">();
	}
	static class UPlayspaceGameStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceGameStateComponent>();
	}
};
static_assert(alignof(UPlayspaceGameStateComponent) == 0x000008, "Wrong alignment on UPlayspaceGameStateComponent");
static_assert(sizeof(UPlayspaceGameStateComponent) == 0x0000B0, "Wrong size on UPlayspaceGameStateComponent");

// Class PlayspaceFramework.PlayspaceGameStateComponent_PlayerSpawningManager
// 0x0040 (0x00F0 - 0x00B0)
class UPlayspaceGameStateComponent_PlayerSpawningManager final : public UPlayspaceGameStateComponent
{
public:
	uint8                                         Pad_3F69[0x30];                                    // 0x00B0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayspaceSpawningInfo>         SpawningUsersArray;                                // 0x00E0(0x0010)(ZeroConstructor, Transient, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceGameStateComponent_PlayerSpawningManager">();
	}
	static class UPlayspaceGameStateComponent_PlayerSpawningManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceGameStateComponent_PlayerSpawningManager>();
	}
};
static_assert(alignof(UPlayspaceGameStateComponent_PlayerSpawningManager) == 0x000008, "Wrong alignment on UPlayspaceGameStateComponent_PlayerSpawningManager");
static_assert(sizeof(UPlayspaceGameStateComponent_PlayerSpawningManager) == 0x0000F0, "Wrong size on UPlayspaceGameStateComponent_PlayerSpawningManager");
static_assert(offsetof(UPlayspaceGameStateComponent_PlayerSpawningManager, SpawningUsersArray) == 0x0000E0, "Member 'UPlayspaceGameStateComponent_PlayerSpawningManager::SpawningUsersArray' has a wrong offset!");

// Class PlayspaceFramework.PlayspaceLibrary
// 0x0000 (0x0028 - 0x0028)
class UPlayspaceLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceLibrary">();
	}
	static class UPlayspaceLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceLibrary>();
	}
};
static_assert(alignof(UPlayspaceLibrary) == 0x000008, "Wrong alignment on UPlayspaceLibrary");
static_assert(sizeof(UPlayspaceLibrary) == 0x000028, "Wrong size on UPlayspaceLibrary");

// Class PlayspaceFramework.PlayspaceLogic
// 0x0010 (0x0230 - 0x0220)
class APlayspaceLogic : public AActor
{
public:
	class APlayspace*                             Playspace;                                         // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoStartMatchOnServerStart;                      // 0x0228(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F6A[0x1];                                     // 0x0229(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMatchHasEnded;                                    // 0x022A(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F6B[0x1];                                     // 0x022B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MatchStartTime;                                    // 0x022C(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_bMatchHasEnded();
	void OnRep_MatchStartTime();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceLogic">();
	}
	static class APlayspaceLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayspaceLogic>();
	}
};
static_assert(alignof(APlayspaceLogic) == 0x000008, "Wrong alignment on APlayspaceLogic");
static_assert(sizeof(APlayspaceLogic) == 0x000230, "Wrong size on APlayspaceLogic");
static_assert(offsetof(APlayspaceLogic, Playspace) == 0x000220, "Member 'APlayspaceLogic::Playspace' has a wrong offset!");
static_assert(offsetof(APlayspaceLogic, bAutoStartMatchOnServerStart) == 0x000228, "Member 'APlayspaceLogic::bAutoStartMatchOnServerStart' has a wrong offset!");
static_assert(offsetof(APlayspaceLogic, bMatchHasEnded) == 0x00022A, "Member 'APlayspaceLogic::bMatchHasEnded' has a wrong offset!");
static_assert(offsetof(APlayspaceLogic, MatchStartTime) == 0x00022C, "Member 'APlayspaceLogic::MatchStartTime' has a wrong offset!");

// Class PlayspaceFramework.PlayspaceLogicComponent
// 0x0000 (0x00B0 - 0x00B0)
class UPlayspaceLogicComponent : public UGameFrameworkComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceLogicComponent">();
	}
	static class UPlayspaceLogicComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceLogicComponent>();
	}
};
static_assert(alignof(UPlayspaceLogicComponent) == 0x000008, "Wrong alignment on UPlayspaceLogicComponent");
static_assert(sizeof(UPlayspaceLogicComponent) == 0x0000B0, "Wrong size on UPlayspaceLogicComponent");

// Class PlayspaceFramework.PlayspaceLogicComponent_PlayerSpawning
// 0x0010 (0x00C0 - 0x00B0)
class UPlayspaceLogicComponent_PlayerSpawning final : public UPlayspaceLogicComponent
{
public:
	bool                                          bQueueUserForSpawnWhenAdded;                       // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F6C[0x3];                                     // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnDelayMin;                                     // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SpawnDelayMax;                                     // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F6D[0x4];                                     // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceLogicComponent_PlayerSpawning">();
	}
	static class UPlayspaceLogicComponent_PlayerSpawning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceLogicComponent_PlayerSpawning>();
	}
};
static_assert(alignof(UPlayspaceLogicComponent_PlayerSpawning) == 0x000008, "Wrong alignment on UPlayspaceLogicComponent_PlayerSpawning");
static_assert(sizeof(UPlayspaceLogicComponent_PlayerSpawning) == 0x0000C0, "Wrong size on UPlayspaceLogicComponent_PlayerSpawning");
static_assert(offsetof(UPlayspaceLogicComponent_PlayerSpawning, bQueueUserForSpawnWhenAdded) == 0x0000B0, "Member 'UPlayspaceLogicComponent_PlayerSpawning::bQueueUserForSpawnWhenAdded' has a wrong offset!");
static_assert(offsetof(UPlayspaceLogicComponent_PlayerSpawning, SpawnDelayMin) == 0x0000B4, "Member 'UPlayspaceLogicComponent_PlayerSpawning::SpawnDelayMin' has a wrong offset!");
static_assert(offsetof(UPlayspaceLogicComponent_PlayerSpawning, SpawnDelayMax) == 0x0000B8, "Member 'UPlayspaceLogicComponent_PlayerSpawning::SpawnDelayMax' has a wrong offset!");

// Class PlayspaceFramework.PlayspaceManagerComponent
// 0x0030 (0x00E0 - 0x00B0)
class UPlayspaceManagerComponent final : public UGameStateComponent
{
public:
	class APlayspace*                             RootPlayspace;                                     // 0x00B0(0x0008)(Net, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F6E[0x8];                                     // 0x00B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FActorOverlapEvent>             UnhandledEnterEvents;                              // 0x00C0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FActorOverlapEvent>             UnhandledExitEvents;                               // 0x00D0(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnPlayerBeginOverlapGameplayVolume(class APlayerState* PlayerState, class AGameplayVolume* Volume);
	void OnPlayerEndOverlapGameplayVolume(class APlayerState* PlayerState, class AGameplayVolume* Volume);
	bool ProcessOverlapEvents(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayspaceManagerComponent">();
	}
	static class UPlayspaceManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayspaceManagerComponent>();
	}
};
static_assert(alignof(UPlayspaceManagerComponent) == 0x000008, "Wrong alignment on UPlayspaceManagerComponent");
static_assert(sizeof(UPlayspaceManagerComponent) == 0x0000E0, "Wrong size on UPlayspaceManagerComponent");
static_assert(offsetof(UPlayspaceManagerComponent, RootPlayspace) == 0x0000B0, "Member 'UPlayspaceManagerComponent::RootPlayspace' has a wrong offset!");
static_assert(offsetof(UPlayspaceManagerComponent, UnhandledEnterEvents) == 0x0000C0, "Member 'UPlayspaceManagerComponent::UnhandledEnterEvents' has a wrong offset!");
static_assert(offsetof(UPlayspaceManagerComponent, UnhandledExitEvents) == 0x0000D0, "Member 'UPlayspaceManagerComponent::UnhandledExitEvents' has a wrong offset!");

}

