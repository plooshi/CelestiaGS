#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: CreativeMiniGameMessage

#include "Basic.hpp"

#include "CreativeMiniGameMessage_classes.hpp"
#include "CreativeMiniGameMessage_parameters.hpp"


namespace SDK
{

// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.ExecuteUbergraph_CreativeMiniGameMessage
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UCreativeMiniGameMessage_C::ExecuteUbergraph_CreativeMiniGameMessage(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "ExecuteUbergraph_CreativeMiniGameMessage");

	Params::CreativeMiniGameMessage_C_ExecuteUbergraph_CreativeMiniGameMessage Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.UpdateVisibility
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortMinigame*                    MinigameToCheck                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UCreativeMiniGameMessage_C::UpdateVisibility(class AFortMinigame* MinigameToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "UpdateVisibility");

	Params::CreativeMiniGameMessage_C_UpdateVisibility Parms{};

	Parms.MinigameToCheck = MinigameToCheck;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.TrySetup
// (BlueprintCallable, BlueprintEvent)

void UCreativeMiniGameMessage_C::TrySetup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "TrySetup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.OnStartingGame
// (BlueprintCallable, BlueprintEvent)

void UCreativeMiniGameMessage_C::OnStartingGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "OnStartingGame");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.OnMinigameStateChanged
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortMinigame*                    ChangedMinigame                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EFortMinigameState                      MinigameState                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UCreativeMiniGameMessage_C::OnMinigameStateChanged(class AFortMinigame* ChangedMinigame, EFortMinigameState MinigameState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "OnMinigameStateChanged");

	Params::CreativeMiniGameMessage_C_OnMinigameStateChanged Parms{};

	Parms.ChangedMinigame = ChangedMinigame;
	Parms.MinigameState = MinigameState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.BindGlobalEvents
// (BlueprintCallable, BlueprintEvent)

void UCreativeMiniGameMessage_C::BindGlobalEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "BindGlobalEvents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.UnbindGlobalEvents
// (BlueprintCallable, BlueprintEvent)

void UCreativeMiniGameMessage_C::UnbindGlobalEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "UnbindGlobalEvents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.DisableMessage
// (BlueprintCallable, BlueprintEvent)

void UCreativeMiniGameMessage_C::DisableMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "DisableMessage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.OnEnterVolume
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerState*                     Client                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AFortVolume*                      Volume                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UCreativeMiniGameMessage_C::OnEnterVolume(class APlayerState* Client, class AFortVolume* Volume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "OnEnterVolume");

	Params::CreativeMiniGameMessage_C_OnEnterVolume Parms{};

	Parms.Client = Client;
	Parms.Volume = Volume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.OnLeaveIsland
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortPlayerPawn*                  PlayerPawn                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UCreativeMiniGameMessage_C::OnLeaveIsland(class AFortPlayerPawn* PlayerPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "OnLeaveIsland");

	Params::CreativeMiniGameMessage_C_OnLeaveIsland Parms{};

	Parms.PlayerPawn = PlayerPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.UnBindMiniGameEvents
// (BlueprintCallable, BlueprintEvent)

void UCreativeMiniGameMessage_C::UnBindMiniGameEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "UnBindMiniGameEvents");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.BindMiniGameEvents
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortVolume*                      MinigameVolume                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UCreativeMiniGameMessage_C::BindMiniGameEvents(class AFortVolume* MinigameVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "BindMiniGameEvents");

	Params::CreativeMiniGameMessage_C_BindMiniGameEvents Parms{};

	Parms.MinigameVolume = MinigameVolume;

	UObject::ProcessEvent(Func, &Parms);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.Destruct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UCreativeMiniGameMessage_C::Destruct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "Destruct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.Construct
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UCreativeMiniGameMessage_C::Construct()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "Construct");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.SetVisibilityForPublishedIslands
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortMinigame*                    MinigameToCheck                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIsVisible                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UCreativeMiniGameMessage_C::SetVisibilityForPublishedIslands(class AFortMinigame* MinigameToCheck, bool* bIsVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "SetVisibilityForPublishedIslands");

	Params::CreativeMiniGameMessage_C_SetVisibilityForPublishedIslands Parms{};

	Parms.MinigameToCheck = MinigameToCheck;

	UObject::ProcessEvent(Func, &Parms);

	if (bIsVisible != nullptr)
		*bIsVisible = Parms.bIsVisible;
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.HandleLoadingScreenChanged
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortPlayerControllerAthena*      PlayerController                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bEnabled                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FText                             HUDReasonText                                          (BlueprintVisible, BlueprintReadOnly, Parm)

void UCreativeMiniGameMessage_C::HandleLoadingScreenChanged(class AFortPlayerControllerAthena* PlayerController, bool bEnabled, const class FText& HUDReasonText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "HandleLoadingScreenChanged");

	Params::CreativeMiniGameMessage_C_HandleLoadingScreenChanged Parms{};

	Parms.PlayerController = PlayerController;
	Parms.bEnabled = bEnabled;
	Parms.HUDReasonText = move(HUDReasonText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.FinishVolumeBinding
// (Public, BlueprintCallable, BlueprintEvent)

void UCreativeMiniGameMessage_C::FinishVolumeBinding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "FinishVolumeBinding");

	UObject::ProcessEvent(Func, nullptr);
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.ShouldRetry
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShouldRetry                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UCreativeMiniGameMessage_C::ShouldRetry(bool* bShouldRetry)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "ShouldRetry");

	Params::CreativeMiniGameMessage_C_ShouldRetry Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldRetry != nullptr)
		*bShouldRetry = Parms.bShouldRetry;
}


// Function CreativeMiniGameMessage.CreativeMiniGameMessage_C.GetMinigameHelper
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AFortVolume*                      VolumeToCheck                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AFortMinigame*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

class AFortMinigame* UCreativeMiniGameMessage_C::GetMinigameHelper(class AFortVolume* VolumeToCheck)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CreativeMiniGameMessage_C", "GetMinigameHelper");

	Params::CreativeMiniGameMessage_C_GetMinigameHelper Parms{};

	Parms.VolumeToCheck = VolumeToCheck;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

