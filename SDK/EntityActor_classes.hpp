#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: EntityActor

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "EntityCore_classes.hpp"
#include "EntityActor_structs.hpp"
#include "CoreUObject_structs.hpp"


namespace SDK
{

// Class EntityActor.EntityActorPlayerComponent
// 0x0078 (0x00D8 - 0x0060)
class UEntityActorPlayerComponent final : public UEntityDataBackedComponent
{
public:
	TSoftObjectPtr<class APlayerController>       PlayerControllerCache;                             // 0x0060(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class APlayerState>            PlayerStateCache;                                  // 0x0088(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FUniqueNetIdRepl                       PlayerID;                                          // 0x00B0(0x0028)(HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorPlayerComponent">();
	}
	static class UEntityActorPlayerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorPlayerComponent>();
	}
};
static_assert(alignof(UEntityActorPlayerComponent) == 0x000008, "Wrong alignment on UEntityActorPlayerComponent");
static_assert(sizeof(UEntityActorPlayerComponent) == 0x0000D8, "Wrong size on UEntityActorPlayerComponent");
static_assert(offsetof(UEntityActorPlayerComponent, PlayerControllerCache) == 0x000060, "Member 'UEntityActorPlayerComponent::PlayerControllerCache' has a wrong offset!");
static_assert(offsetof(UEntityActorPlayerComponent, PlayerStateCache) == 0x000088, "Member 'UEntityActorPlayerComponent::PlayerStateCache' has a wrong offset!");
static_assert(offsetof(UEntityActorPlayerComponent, PlayerID) == 0x0000B0, "Member 'UEntityActorPlayerComponent::PlayerID' has a wrong offset!");

// Class EntityActor.ActorToEntityAdapterComponent
// 0x0020 (0x00D0 - 0x00B0)
class UActorToEntityAdapterComponent final : public UActorComponent
{
public:
	int32                                         EntityID;                                          // 0x00B0(0x0004)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4950[0x4];                                     // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEntityComponent*>               SerializedComponents;                              // 0x00B8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4951[0x8];                                     // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorToEntityAdapterComponent">();
	}
	static class UActorToEntityAdapterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UActorToEntityAdapterComponent>();
	}
};
static_assert(alignof(UActorToEntityAdapterComponent) == 0x000008, "Wrong alignment on UActorToEntityAdapterComponent");
static_assert(sizeof(UActorToEntityAdapterComponent) == 0x0000D0, "Wrong size on UActorToEntityAdapterComponent");
static_assert(offsetof(UActorToEntityAdapterComponent, EntityID) == 0x0000B0, "Member 'UActorToEntityAdapterComponent::EntityID' has a wrong offset!");
static_assert(offsetof(UActorToEntityAdapterComponent, SerializedComponents) == 0x0000B8, "Member 'UActorToEntityAdapterComponent::SerializedComponents' has a wrong offset!");

// Class EntityActor.EntityActorCollisionComponent
// 0x0078 (0x00F0 - 0x0078)
class UEntityActorCollisionComponent final : public UEntityEnableableComponent
{
public:
	uint8                                         Pad_4952[0x48];                                    // 0x0078(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UPrimitiveComponent>     PrimitiveComponentCache;                           // 0x00C0(0x0028)(ExportObject, InstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4953[0x8];                                     // 0x00E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnNativeComponentBeginOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnNativeComponentEndOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnNativeComponentHit(class UPrimitiveComponent* HitComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorCollisionComponent">();
	}
	static class UEntityActorCollisionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorCollisionComponent>();
	}
};
static_assert(alignof(UEntityActorCollisionComponent) == 0x000008, "Wrong alignment on UEntityActorCollisionComponent");
static_assert(sizeof(UEntityActorCollisionComponent) == 0x0000F0, "Wrong size on UEntityActorCollisionComponent");
static_assert(offsetof(UEntityActorCollisionComponent, PrimitiveComponentCache) == 0x0000C0, "Member 'UEntityActorCollisionComponent::PrimitiveComponentCache' has a wrong offset!");

// Class EntityActor.EntityActorPositionComponent
// 0x0038 (0x0098 - 0x0060)
class UEntityActorPositionComponent final : public UEntityPositionComponent
{
public:
	struct FVector                                ShadowVar_Location;                                // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4957[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USceneComponent>         RootComponentCache;                                // 0x0070(0x0028)(ExportObject, Transient, InstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRootComponentChanged(class USceneComponent* InRootComponent, bool bIsRootComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorPositionComponent">();
	}
	static class UEntityActorPositionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorPositionComponent>();
	}
};
static_assert(alignof(UEntityActorPositionComponent) == 0x000008, "Wrong alignment on UEntityActorPositionComponent");
static_assert(sizeof(UEntityActorPositionComponent) == 0x000098, "Wrong size on UEntityActorPositionComponent");
static_assert(offsetof(UEntityActorPositionComponent, ShadowVar_Location) == 0x000060, "Member 'UEntityActorPositionComponent::ShadowVar_Location' has a wrong offset!");
static_assert(offsetof(UEntityActorPositionComponent, RootComponentCache) == 0x000070, "Member 'UEntityActorPositionComponent::RootComponentCache' has a wrong offset!");

// Class EntityActor.EntityActorCustomReplicationComponent
// 0x0008 (0x0060 - 0x0058)
class UEntityActorCustomReplicationComponent final : public UEntityComponent
{
public:
	EEntityActorReplicationOverrideType           ReplicationOverride;                               // 0x0058(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEntityActorReplicationRelevancyBucketType    ReplicationRelevancyBucketType;                    // 0x0059(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4959[0x2];                                     // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CustomReplicationRelevancyRange;                   // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorCustomReplicationComponent">();
	}
	static class UEntityActorCustomReplicationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorCustomReplicationComponent>();
	}
};
static_assert(alignof(UEntityActorCustomReplicationComponent) == 0x000008, "Wrong alignment on UEntityActorCustomReplicationComponent");
static_assert(sizeof(UEntityActorCustomReplicationComponent) == 0x000060, "Wrong size on UEntityActorCustomReplicationComponent");
static_assert(offsetof(UEntityActorCustomReplicationComponent, ReplicationOverride) == 0x000058, "Member 'UEntityActorCustomReplicationComponent::ReplicationOverride' has a wrong offset!");
static_assert(offsetof(UEntityActorCustomReplicationComponent, ReplicationRelevancyBucketType) == 0x000059, "Member 'UEntityActorCustomReplicationComponent::ReplicationRelevancyBucketType' has a wrong offset!");
static_assert(offsetof(UEntityActorCustomReplicationComponent, CustomReplicationRelevancyRange) == 0x00005C, "Member 'UEntityActorCustomReplicationComponent::CustomReplicationRelevancyRange' has a wrong offset!");

// Class EntityActor.EntityActorLocalInputComponent
// 0x0008 (0x0060 - 0x0058)
class UEntityActorLocalInputComponent final : public UEntityComponent
{
public:
	EAutoReceiveInput                             AutoReceiveControllerInput;                        // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_495A[0x7];                                     // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorLocalInputComponent">();
	}
	static class UEntityActorLocalInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorLocalInputComponent>();
	}
};
static_assert(alignof(UEntityActorLocalInputComponent) == 0x000008, "Wrong alignment on UEntityActorLocalInputComponent");
static_assert(sizeof(UEntityActorLocalInputComponent) == 0x000060, "Wrong size on UEntityActorLocalInputComponent");
static_assert(offsetof(UEntityActorLocalInputComponent, AutoReceiveControllerInput) == 0x000058, "Member 'UEntityActorLocalInputComponent::AutoReceiveControllerInput' has a wrong offset!");

// Class EntityActor.EntityActorRotationComponent
// 0x0038 (0x0098 - 0x0060)
class UEntityActorRotationComponent final : public UEntityRotationComponent
{
public:
	struct FRotator                               ShadowVar_Rotation;                                // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_495B[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USceneComponent>         RootComponentCache;                                // 0x0070(0x0028)(ExportObject, Transient, InstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRootComponentChanged(class USceneComponent* InRootComponent, bool bIsRootComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorRotationComponent">();
	}
	static class UEntityActorRotationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorRotationComponent>();
	}
};
static_assert(alignof(UEntityActorRotationComponent) == 0x000008, "Wrong alignment on UEntityActorRotationComponent");
static_assert(sizeof(UEntityActorRotationComponent) == 0x000098, "Wrong size on UEntityActorRotationComponent");
static_assert(offsetof(UEntityActorRotationComponent, ShadowVar_Rotation) == 0x000060, "Member 'UEntityActorRotationComponent::ShadowVar_Rotation' has a wrong offset!");
static_assert(offsetof(UEntityActorRotationComponent, RootComponentCache) == 0x000070, "Member 'UEntityActorRotationComponent::RootComponentCache' has a wrong offset!");

// Class EntityActor.EntityActorScaleComponent
// 0x0038 (0x0098 - 0x0060)
class UEntityActorScaleComponent final : public UEntityScaleComponent
{
public:
	struct FVector                                ShadowVar_Scale;                                   // 0x0060(0x000C)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_495D[0x4];                                     // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USceneComponent>         RootComponentCache;                                // 0x0070(0x0028)(ExportObject, Transient, InstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRootComponentChanged(class USceneComponent* InRootComponent, bool bIsRootComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorScaleComponent">();
	}
	static class UEntityActorScaleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorScaleComponent>();
	}
};
static_assert(alignof(UEntityActorScaleComponent) == 0x000008, "Wrong alignment on UEntityActorScaleComponent");
static_assert(sizeof(UEntityActorScaleComponent) == 0x000098, "Wrong size on UEntityActorScaleComponent");
static_assert(offsetof(UEntityActorScaleComponent, ShadowVar_Scale) == 0x000060, "Member 'UEntityActorScaleComponent::ShadowVar_Scale' has a wrong offset!");
static_assert(offsetof(UEntityActorScaleComponent, RootComponentCache) == 0x000070, "Member 'UEntityActorScaleComponent::RootComponentCache' has a wrong offset!");

// Class EntityActor.EntityActorSkeletalMeshRenderComponent
// 0x0040 (0x0098 - 0x0058)
class UEntityActorSkeletalMeshRenderComponent final : public UEntityComponent
{
public:
	TSoftObjectPtr<class USkeletalMeshComponent>  SkeletalMeshComponentCache;                        // 0x0058(0x0028)(ExportObject, InstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_495F[0x8];                                     // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMesh*                          ShadowVar_SkeletalMesh;                            // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionEnabled                             ShadowVar_EnableCollision;                         // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4960[0x7];                                     // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorSkeletalMeshRenderComponent">();
	}
	static class UEntityActorSkeletalMeshRenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorSkeletalMeshRenderComponent>();
	}
};
static_assert(alignof(UEntityActorSkeletalMeshRenderComponent) == 0x000008, "Wrong alignment on UEntityActorSkeletalMeshRenderComponent");
static_assert(sizeof(UEntityActorSkeletalMeshRenderComponent) == 0x000098, "Wrong size on UEntityActorSkeletalMeshRenderComponent");
static_assert(offsetof(UEntityActorSkeletalMeshRenderComponent, SkeletalMeshComponentCache) == 0x000058, "Member 'UEntityActorSkeletalMeshRenderComponent::SkeletalMeshComponentCache' has a wrong offset!");
static_assert(offsetof(UEntityActorSkeletalMeshRenderComponent, ShadowVar_SkeletalMesh) == 0x000088, "Member 'UEntityActorSkeletalMeshRenderComponent::ShadowVar_SkeletalMesh' has a wrong offset!");
static_assert(offsetof(UEntityActorSkeletalMeshRenderComponent, ShadowVar_EnableCollision) == 0x000090, "Member 'UEntityActorSkeletalMeshRenderComponent::ShadowVar_EnableCollision' has a wrong offset!");

// Class EntityActor.EntityActorStaticMeshRenderComponent
// 0x0030 (0x00A8 - 0x0078)
class UEntityActorStaticMeshRenderComponent final : public UEntityEnableableComponent
{
public:
	TWeakObjectPtr<class UStaticMeshComponent>    StaticMeshComponentCache;                          // 0x0078(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4961[0x8];                                     // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMesh*                            ShadowVar_StaticMesh;                              // 0x0088(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UMaterialInterface*>             ShadowVar_MeshMaterials;                           // 0x0090(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ECollisionEnabled                             ShadowVar_EnableCollision;                         // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         TargetMeshIndex;                                   // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         ShadowVar_Visible : 1;                             // 0x00A2(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_4962[0x1];                                     // 0x00A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShadowVar_MaxDrawDistance;                         // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorStaticMeshRenderComponent">();
	}
	static class UEntityActorStaticMeshRenderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorStaticMeshRenderComponent>();
	}
};
static_assert(alignof(UEntityActorStaticMeshRenderComponent) == 0x000008, "Wrong alignment on UEntityActorStaticMeshRenderComponent");
static_assert(sizeof(UEntityActorStaticMeshRenderComponent) == 0x0000A8, "Wrong size on UEntityActorStaticMeshRenderComponent");
static_assert(offsetof(UEntityActorStaticMeshRenderComponent, StaticMeshComponentCache) == 0x000078, "Member 'UEntityActorStaticMeshRenderComponent::StaticMeshComponentCache' has a wrong offset!");
static_assert(offsetof(UEntityActorStaticMeshRenderComponent, ShadowVar_StaticMesh) == 0x000088, "Member 'UEntityActorStaticMeshRenderComponent::ShadowVar_StaticMesh' has a wrong offset!");
static_assert(offsetof(UEntityActorStaticMeshRenderComponent, ShadowVar_MeshMaterials) == 0x000090, "Member 'UEntityActorStaticMeshRenderComponent::ShadowVar_MeshMaterials' has a wrong offset!");
static_assert(offsetof(UEntityActorStaticMeshRenderComponent, ShadowVar_EnableCollision) == 0x0000A0, "Member 'UEntityActorStaticMeshRenderComponent::ShadowVar_EnableCollision' has a wrong offset!");
static_assert(offsetof(UEntityActorStaticMeshRenderComponent, TargetMeshIndex) == 0x0000A1, "Member 'UEntityActorStaticMeshRenderComponent::TargetMeshIndex' has a wrong offset!");
static_assert(offsetof(UEntityActorStaticMeshRenderComponent, ShadowVar_MaxDrawDistance) == 0x0000A4, "Member 'UEntityActorStaticMeshRenderComponent::ShadowVar_MaxDrawDistance' has a wrong offset!");

// Class EntityActor.EntityActorSubsystem
// 0x0020 (0x0050 - 0x0030)
class UEntityActorSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_4963[0x20];                                    // 0x0030(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorSubsystem">();
	}
	static class UEntityActorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorSubsystem>();
	}
};
static_assert(alignof(UEntityActorSubsystem) == 0x000008, "Wrong alignment on UEntityActorSubsystem");
static_assert(sizeof(UEntityActorSubsystem) == 0x000050, "Wrong size on UEntityActorSubsystem");

// Class EntityActor.EntityActorTextDisplayComponent
// 0x0048 (0x00A0 - 0x0058)
class UEntityActorTextDisplayComponent final : public UEntityComponent
{
public:
	class FText                                   DisplayText;                                       // 0x0058(0x0018)(Edit, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTextRenderComponent>    TextRenderComponentCache;                          // 0x0070(0x0028)(ExportObject, InstancedReference, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4964[0x8];                                     // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EHorizTextAligment GetHorizontalAlignment();
	struct FVector GetRelativeLocation();
	EVerticalTextAligment GetVerticalAlignment();
	void SetHorizontalAlignment(EHorizTextAligment Value);
	void SetRelativeLocation(const struct FVector& RelativeLocation);
	void SetRelativeRotation(const struct FRotator& RelativeRotation);
	void SetRelativeScale(const struct FVector& RelativeScale);
	void SetText(const class FText& Text);
	void SetTextRenderColor(const struct FColor& Value);
	void SetVerticalAlignment(EVerticalTextAligment Value);
	void SetWorldSize(float Value);

	class FText GetText() const;
	struct FColor GetTextRenderColor() const;
	float GetWorldSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityActorTextDisplayComponent">();
	}
	static class UEntityActorTextDisplayComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityActorTextDisplayComponent>();
	}
};
static_assert(alignof(UEntityActorTextDisplayComponent) == 0x000008, "Wrong alignment on UEntityActorTextDisplayComponent");
static_assert(sizeof(UEntityActorTextDisplayComponent) == 0x0000A0, "Wrong size on UEntityActorTextDisplayComponent");
static_assert(offsetof(UEntityActorTextDisplayComponent, DisplayText) == 0x000058, "Member 'UEntityActorTextDisplayComponent::DisplayText' has a wrong offset!");
static_assert(offsetof(UEntityActorTextDisplayComponent, TextRenderComponentCache) == 0x000070, "Member 'UEntityActorTextDisplayComponent::TextRenderComponentCache' has a wrong offset!");

// Class EntityActor.EntityDynamicActivationComponent
// 0x0038 (0x00B0 - 0x0078)
class UEntityDynamicActivationComponent final : public UEntityEnableableComponent
{
public:
	uint8                                         Pad_4965[0x8];                                     // 0x0078(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionTargetTime;                              // 0x0080(0x0004)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTargetState;                                      // 0x0084(0x0001)(Net, ZeroConstructor, Transient, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4966[0x3];                                     // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEntityComponent*>               LinkedComponents;                                  // 0x0088(0x0010)(Net, ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4967[0x18];                                    // 0x0098(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEnabledChanged(bool bIsEnabled);
	void OnRep_TransitionTarget();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityDynamicActivationComponent">();
	}
	static class UEntityDynamicActivationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityDynamicActivationComponent>();
	}
};
static_assert(alignof(UEntityDynamicActivationComponent) == 0x000008, "Wrong alignment on UEntityDynamicActivationComponent");
static_assert(sizeof(UEntityDynamicActivationComponent) == 0x0000B0, "Wrong size on UEntityDynamicActivationComponent");
static_assert(offsetof(UEntityDynamicActivationComponent, TransitionTargetTime) == 0x000080, "Member 'UEntityDynamicActivationComponent::TransitionTargetTime' has a wrong offset!");
static_assert(offsetof(UEntityDynamicActivationComponent, bTargetState) == 0x000084, "Member 'UEntityDynamicActivationComponent::bTargetState' has a wrong offset!");
static_assert(offsetof(UEntityDynamicActivationComponent, LinkedComponents) == 0x000088, "Member 'UEntityDynamicActivationComponent::LinkedComponents' has a wrong offset!");

// Class EntityActor.EntityToActorAdapterComponent
// 0x0008 (0x0060 - 0x0058)
class UEntityToActorAdapterComponent final : public UEntityComponent
{
public:
	TWeakObjectPtr<class AActor>                  Actor;                                             // 0x0058(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EntityToActorAdapterComponent">();
	}
	static class UEntityToActorAdapterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEntityToActorAdapterComponent>();
	}
};
static_assert(alignof(UEntityToActorAdapterComponent) == 0x000008, "Wrong alignment on UEntityToActorAdapterComponent");
static_assert(sizeof(UEntityToActorAdapterComponent) == 0x000060, "Wrong size on UEntityToActorAdapterComponent");
static_assert(offsetof(UEntityToActorAdapterComponent, Actor) == 0x000058, "Member 'UEntityToActorAdapterComponent::Actor' has a wrong offset!");

// Class EntityActor.SimObject
// 0x0000 (0x0220 - 0x0220)
class ASimObject final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimObject">();
	}
	static class ASimObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASimObject>();
	}
};
static_assert(alignof(ASimObject) == 0x000008, "Wrong alignment on ASimObject");
static_assert(sizeof(ASimObject) == 0x000220, "Wrong size on ASimObject");

}

